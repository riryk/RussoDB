
1. CLR Hosting


When developing the CLR, Microsoft implemented it as a COM server contained inside a DLL;
that is, Microsoft defined a standard COM interface for the CLR and assigned GUIDs to this interface
and the COM server. When you install the .NET Framework, the COM server representing the CLR is
registered in the Windows registry just as any other COM server would. If you want more information
about this topic, refer to the MetaHost.h C++ header file that ships with the .NET Framework SDK.
This header file defines the GUIDs and the unmanaged ICLRMetaHost interface definition.

2. What happens when a managed executable starts.

By default, when a managed executable starts, the shim examines the executable file and extracts
the information indicating the version of the CLR that the application was built and tested
with.
Initialize and start the CLR.
Load an assembly and execute code in it.

3. How does Windows know that a binary is a .NET application?

Normally .exe files are executed by Windows by looking at the PE-Header. 
This PE-Header says how it should be loaded into memory, 
what dependencies it has, and where the entry point is.

4. Where is the entry-point of a .NET application?

Well, your application is in some IL-code. 
Executing that directly will clearly lead to a crash. 
It is not the IL-code that should start executing, 
but the .NET runtime, which eventually should load the IL-code and execute it.

In newer versions of Windows, .NET comes preinstalled, 
and Windows has built-in support for recognizing a .NET application. 
This can be done by simply looking in the PE-Header present in all executables and DLLs. 
In older versions of Windows, execution is passed to an entry point 
where boot-strapper code is located. 

The boot-strapper, which is native code, uses an unmanaged CLR Hosting API, 
to start the .NET runtime inside the current process 
and launch the real program which is the IL-code.

5. Hosting the CLR in an unmanaged app

When you start the .NET runtime inside a native process, 
that native application becomes a host for the runtime. 
This lets you add .NET capabilities to your native applications.

#include <metahost.h>
#include <mscoree.h>
#pragma comment(lib, "mscoree.lib")

ICLRMetaHost    *pMetaHost     = nullptr;
ICLRRuntimeHost *pRuntimeHost  = nullptr;
ICLRRuntimeInfo *pRuntimeInfo  = nullptr;
HRESULT hr;

hr = CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, (LPVOID*)&pMetaHost);
hr = pMetaHost->GetRuntime(runtimeVersion, IID_PPV_ARGS(&pRuntimeInfo));
hr = pRuntimeInfo->GetInterface(CLSID_CLRRuntimeHost,IID_PPV_ARGS(&pRuntimeHost));
hr = pRuntimeHost->Start();

_AppDomain* pCurrentDomain = nullptr;
hr = pRuntimeHost->GetDefaultDomain(&pCurrentDomain);
pCurrentDomain.ExecuteAssembly(assemblyFilename);


Now the runtime is running, but it hasn't got any loaded user code yet. 
Some internal thread scheduler and garbage collector are surely running, 
because they are part of the CLR runtime.


To be able to register a new AppDomainManager, 
we will need an interface called ICLRControl. 
This interface contains a method SetAppDomainManagerType, 
which loads your managed implementation of the AppDomainManager.


ICLRControl* pCLRControl = nullptr;
hr = pRuntimeHost->GetCLRControl(&pCLRControl);
LPCWSTR assemblyName = L"SampleAppDomainManager";
LPCWSTR appDomainManagerTypename = L"SampleAppDomainManager.CustomAppDomainManager";
hr = pCLRControl->SetAppDomainManagerType(assemblyName, appDomainManagerTypename);


[GuidAttribute("0C19678A-CE6C-487B-AD36-0A8B7D7CC035"), ComVisible(true)]
public sealed class CustomAppDomainManager : AppDomainManager, ICustomAppDomainManager
{
  public CustomAppDomainManager()
  {
     System.Console.WriteLine("*** Instantiated CustomAppDomainManager");
  }

  public override void InitializeNewDomain(AppDomainSetup appDomainInfo)
  {
     System.Console.WriteLine("*** InitializeNewDomain");
     this.InitializationFlags = AppDomainManagerInitializationOptions.RegisterWithHost;
  }

  public override AppDomain CreateDomain(string friendlyName,
          Evidence securityInfo, AppDomainSetup appDomainInfo)
  {
     var appDomain = base.CreateDomain(friendlyName, securityInfo, appDomainInfo);
     System.Console.WriteLine("*** Created AppDomain {0}", friendlyName);
     return appDomain;
  }
}

Before any managed code can be executed, 
the host must load and initialize the common language runtime.
All hosts start with an unmanaged stub because the runtime is not yet running in the process.

After loading and initializing the common language runtime, 
the host must make the transition from unmanaged to managed code 
in order to execute managed hosting code and user code.

After a host has determined where domain boundaries lie, 
based on the criteria described in the previous section, 
the host uses the CreateDomain method of the System.AppDomain type 
to create domains in which to run user code. 
Each application domain contains a collection of name/value pairs 
in which a host can store information about a domain. 
The name/value pairs are passed as a parameter to CreateDomain.


6. AppDomains.


When the CLR COM server initializes, it creates an AppDomain. An AppDomain is a logical container
for a set of assemblies. The first AppDomain created when the CLR is initialized is called the default
AppDomain; this AppDomain is destroyed only when the Windows process terminates.

In addition to the default AppDomain, a host using either unmanaged COM interface methods or
managed type methods can instruct the CLR to create additional AppDomains. The whole purpose of
an AppDomain is to provide isolation. Here are the specific features offered by an AppDomain:

- Objects created by code in one AppDomain cannot be accessed directly by code in another

AppDomain When code in an AppDomain creates an object, that object is “owned”
by that AppDomain. In other words, the object is not allowed to live beyond the lifetime of
the AppDomain whose code constructed it. Code in other AppDomains can access another
AppDomain’s object only by using marshal-by-reference or marshal-by-value semantics. This
enforces a clean separation and boundary because code in one AppDomain can’t have a
direct reference to an object created by code in a different AppDomain.

-AppDomains can be unloaded The CLR doesn’t support the ability to unload a single assembly

from an AppDomain. However, you can tell the CLR to unload an AppDomain, which
will cause all of the assemblies currently contained in it to be unloaded as well.

-AppDomains can be individually secured 
When created, an AppDomain can have a permission
set applied to it that determines the maximum rights granted to assemblies running
in the AppDomain. This allows a host to load some code and be ensured that the code cannot
corrupt or read important data structures used by the host itself.

Important A great feature of Windows is that it runs each application in its own process
address space. This ensures that code in one application cannot access code or data in use
by another application. Process isolation prevents security holes, data corruption, and other
unpredictable behaviors from occurring, making Windows and the applications running
on it robust. Unfortunately, creating processes in Windows is very expensive. The Win32
CreateProcess function is very slow, and Windows requires a lot of memory to virtualize
a process’s address space.

However, if an application consists entirely of managed code that is verifiably safe and
doesn’t call out into unmanaged code, there are no problems related to running multiple
managed applications in a single Windows process. And AppDomains provide the isolation
required to secure, configure, and terminate each of these applications.

each type object
in the loader heap has a method table, and each entry in the method table points to JIT-compiled native
code if the method has been executed at least once.

Furthermore, as code in an AppDomain calls methods defined by a type, the method’s
Intermediate Language (IL) code is JIT-compiled, and the resulting native code is associated with each
AppDomain;

Some assemblies are expected to be used by several AppDomains. MSCorLib.dll is the best example.
This assembly contains System.Object, System.Int32, and all of the other types that are so
integral to the .NET Framework. This assembly is automatically loaded when the CLR initializes, and all
AppDomains share the types in this assembly. To reduce resource usage, MSCorLib.dll is loaded in an
AppDomain-neutral fashion;



7. Accessing Objects Across AppDomain Boundaries.

Marshal by reference communication between two different domains.

{
   AppDomain adCallingThreadDomain = Thread.GetDomain();
   String exeAssembly = Assembly.GetEntryAssembly().FullName;
   
   AppDomain ad2 = AppDomain.CreateDomain("AD #2", null, null);
   mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, "MarshalByRefType");
   
   // Prove that we got a reference to a proxy object
   Console.WriteLine("Is proxy={0}", RemotingServices.IsTransparentProxy(mbrt));

   // This looks like we're calling a method on MarshalByRefType but we're not.
   // We're calling a method on the proxy type. The proxy transitions the thread
   // to the AppDomain owning the object and calls this method on the real object.
   mbrt.SomeMethod();
}


However, a one-to-one
correspondence doesn’t exist between threads and AppDomains. AppDomains are a CLR feature;
Windows knows nothing about AppDomains. Because multiple AppDomains can be in a single
Windows process, a thread can execute code in one AppDomain and then execute code in another
AppDomain. From the CLR’s perspective, a thread is executing code in one AppDomain at a time.


The new AppDomain
will have its very own loader heap, which will be empty because there are currently no assemblies
loading into the new AppDomain. When you create an AppDomain, the CLR does not create any
threads in this AppDomain; no code runs in the AppDomain unless you explicitly have a thread call
code in the AppDomain.

When a source AppDomain wants to send or return the reference of an object to a destination
AppDomain, the CLR defines a proxy type in the destination AppDomain’s loader heap. This proxy
type is defined using the original type’s metadata, and therefore, it looks exactly like the original type;
it has all of the same instance members (properties, events, and methods).








