


The term was introduced by Robert C. Martin in an article by the same name 
as part of his Principles of Object Oriented Design,
made popular by his book Agile Software Development, Principles, Patterns, and Practices.



Site improvements
Alterations to the land that enhance the utility of any structure placed on the site.
Example: Common site improvements include:
- drainage 
- sewerage and other utilities 
- walks and drives
- landscaping 
- fencing


1. Domain Model
                                               Additions
    ----------------- 
   | AdditionBase    |
   | - quantity      |
   | - name          |
   | - reference id  |
   | - depreciation  |   
    ----------------- 
	    ^   ^   ^----------------------------------------------------------------------------
		|    \---------------------------|                                                   |
    ------------------                   V                                                   |
   | Misc Adjustments |           ---------------                                            V
   | - is depreciated |          | Equipment     |                                   -------------------
    -----------------            | - criterias   |                                  | Site improvements |        
	   ^                         | - adjustments | -<>---->   ------------------    |                   |
	   |						  ---------------            | Adjustment       |            ^
	   |						                             | - is depreciated |            |  
	----------------------									 | - cost           |     -----------------------
    | New misc adjustments |                                  ------------------	 | New Site Improvements |		
	-----------------------									                          -----------------------

   Building has a collection of 
     --------------  
    | Building     |                --------------
    | - additions  | -<>---------> | AdditionBase |
     --------------                 -------------- 
	 
 2. Client which creates some additions.
    It can be used in unit tests: 
 
    void createTestBuilding()
	{
	   var equipment = new List<Equipment>();
	   equipment.Adjustments = new Adjustments();
	   equipment.Adjustments.add(new Adjustment);
	   
	   var additions = new List();
	   additions.add(new MiscAdjustments);
	   additions.add(equipment);
	   additions.add(new SiteImprovements);
	}
    
	And the similar create methods can be a lot scattered among application.
	
 3. What changes can affect this code. What can we change in our model
    that will cause rewriting all those createTestBuilding methods.
	If we add new site improvements and new misc adjustments
    we will have to change code.
	
	   -------------------                  -----------
	  | Abstract Factory  |                | ProductA  |           the same for ProductB
	   -------------------                  -----------
	           ^                                ^
               |                                |
          ----- -----                       ---- ----- 
		 |			 |					   |          |			   
		 V           V		               V          V
    		  
	Factory 1     Factory 2			ProductA1		ProductA2								   
	createPrA()
    createPrB()

  4. In our case we have a factory:
                     
	--------------------------------
	|  IAdditionFactory             |
	|  -createMiscAdjustments()     |
	|  -createEquipment()           | 
	|  -createSiteImprovemnts()     | 
	|  -createEquipmentAdjustment() |
	--------------------------------
	            ^
	            |
	    -------- ---------------
	   |                        |  
	   V                        V
  ----------------             ----------------------------
| AdditionFactory1 |           | AdditionFactory2           |
   - new MiscAdjustment()       - new NewMiscAdjustments()  |
   - new SiteImprovements()     - new NewSiteImprovements() |
   - new Equipment()            - new Equipment()           |
   - new EquipmentAdjustment()  - new EquipmentAdjustment() |
  ----------------	            ---------------------------         
	
  5. createTestBuilding method after changing:	
	
    void createTestBuilding(IAdditionFactory factory)
	{
	   var equipment = factory.createEquipment();
	   equipment.Adjustments = new List<Adjustment>();
	   equipment.Adjustments.add(factory.createAdjustment());
	   
	   var additions = new List();
	   additions.add(factory.createMiscAdjustment());
	   additions.add(equipment);
	   additions.add(factory.createSiteImprovement());
	}
	
  6. Pattern builder
       ---------------
      | Builder       |  
	  | -buildPartA() |
	  | -buildPartB() |
	  | -getResult()  |
	   ---------------
	   
	    ---------------
      | Builder1       |  
	  | -buildPartA1() |
	  | -buildPartB1() |
	  | -getResult()   |
	   ---------------
	   
	    ---------------
      | Builder2       |  
	  | -buildPartA2() |
	  | -buildPartB2() |
	  | -getResult()   |
	   ---------------
	       
   Builder hides inward structure of an object.
   If object inward structure is changed, we need to change only builder
   In our case we can create AdditionBuilder.
   
   class AdditionListBuilder
   {
      IAdditionFactory factory;
      List<Addition> additions = new List<Addition>();
	  
	  void AddMiscAdjustment(params)
	  {
	      additions.Add(factory.CreateMiscAdjustmnet(params));
	  }
	  
	  void AddEquipment(params)
	  {
	      additions.Add(factory.CreateEquipment(params));
	  }
	  
	  void AddSiteImprovements(params)
	  {
	      additions.Add(factory.CreateEquipment(params)); 
	  }
   }
   
   So that builder hides the inward relationship among object.
   If the object is complicated, the structure can change often and we 
   do not want to rewrite a lot of code.
   
   
   For additions we have another model: database model 
   which is used in ORM. And we also have a similar model
   in anothert appplication.
   
   | ORMAddition     |
   | - quantity      |
   | - name          |
   | - reference id  |
   | - depreciation  |   
   | - criterias     |              ------------------
   | - adjustments   | -<>-------> |  Adjustment      |
    -----------------              | - is depreciated |
   
   
   And we apply our builder in conversion from ORMAddition to Addition.
   


 3. Factory method:
      ----------
     | Product  |
	  ----------
          ^
          |
      ------------------		  
     | Concrete Product |	  
 	  ------------------
	  
      --------------------
     | BaseCreator        |
     | - createProduct()  |             ----------------------------
	 | - processProject() |-<>-------> |  product = createProject() |
      --------------------              ----------------------------
	          ^
	          | 
	  ---------------------    
	 | ConcreteCreator     |             ------------------------- 
	 | - createProduct()   |-<>-------> | create concrete Project |
	  ---------------------              ------------------------- 
	  
  Application in CHUP:
     -------------------------- 
    | BaseReportType           |   
	| - createReportSettings() | 
	| - useSettings()          |
     --------------------------
	           ^                         -----------------------
	           |                        |  ConcreteReportType   |
	 --------------------------          -----------------------
	|  ConcreteBaseReportType  |               ---------------------------------
    | - createReportSettings() |-<>---------> | return new ConcreteReportType() | 	  
	 --------------------------   
	  
	  
 3. Clone pattern:
     ---------------
    | Prototype     | 
	| - Clone()     |
	 ---------------
           ^
           |
     -------------------
	| ConcretePrototype |
    | - Clone()         |
	 -------------------
	 
	In CHUP clone complicated objects using AutoMapper, serialization or reflection.
	We implement ICloneable interface.
	
 4. Singleton pattern.
 
    public class Singleton
	{
	    private static volatile Singleton instance = NULL;
		private static Object             sync     = new Object();
		
		private Singleton() {}
		
		public static Singleton Instance
		{
		   get
           {
		       if (instance == NULL)
			   {
		           lock (sync)
			       {
		               if (instance == NULL)
			               instance = new Singleton();
			       }
               }			   
			   
			   return instance;
		   }		   
		}
	}
   
    Why is 'volatile' is used here.
	
	Thread1                      Thread2
  Singleton.Instance        Singleton.Instance
  Singleton.Instance        Singleton.Instance
  Singleton.Instance        Singleton.Instance
  Singleton.Instance        Singleton.Instance
  Singleton.Instance        Singleton.Instance
  Singleton.Instance        Singleton.Instance
  
  Without 'volatile':
  
  MOV EAX, [g_x]  0

  mov eax, [instance]       - read from RAM memory to register eax.  
  eax == NULL
  eax == NULL
  mov eax, new Singleton()  - set eax to new Singleton().
  mov [instance], eax       
  ret eax
  
  
      Thread1                        Thread2
  
  mov eax, [instance]            mov eax, [instance] 
  eax == NULL                    eax == NULL
  lock                                .
  eax == NULL                         .
  mov eax, new Singleton()            .
  mov [instance], eax                 .
  unlock                              .
  ret eax                        lock
                                 eax == NULL  
                                 mov eax, new Singleton()           
                                 mov [instance], eax 								 
                                 unlock 
  
  
  
  And in the future we read from 
  
  http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html
  
  
  
  
  // C++ implementation with explicit memory barriers
// Should work on any platform, including DEC Alphas
// From "Patterns for Concurrent and Distributed Objects",
// by Doug Schmidt
template <class TYPE, class LOCK> TYPE *
Singleton<TYPE, LOCK>::instance (void) {
    // First check
    TYPE* tmp = instance_;
    // Insert the CPU-specific memory barrier instruction
    // to synchronize the cache lines on multi-processor.
    asm ("memoryBarrier");
    if (tmp == 0) {
        // Ensure serialization (guard
        // constructor acquires lock_).
        Guard<LOCK> guard (lock_);
        // Double check.
        tmp = instance_;
        if (tmp == 0) {
                tmp = new TYPE;
                // Insert the CPU-specific memory barrier instruction
                // to synchronize the cache lines on multi-processor.
                asm ("memoryBarrier");
                instance_ = tmp;
        }
    return tmp;
    }
	
 5. Adapter pattern
   ----------------                     ------------------
   | IAdaptee      |                    |   IAdapter      |                    
   | -----------   | 	                | --------------- | 
   | SomeMeothod() |                    |   Method()      |    
   ----------------                     ------------------
         ^                                      ^
         |                                      | 
		 |                              -------------------- 
   ------------------                   | ConcreteAdapter   |
   | ConcreteAdaptee |                  |-------------------|   
   |                 | <-----------<>---| adaptee           |   
   | ----------------|                  | Method()          | adaptee.SomeMethod()
   | SomeMethod()    |                  --------------------
   ------------------ 
   
   In calculation engine we have own model:
   
   --------------------------------
   | IBVSCalculator                |
   |-------------------------------| 
   | CalculateValuation(Valuation) | 
   |-------------------------------

  In CHUP we have different model Location and we need an adapter to
  transform calls to BVSCalculator.
  
  class BVSCalculatorAdapter
  {
     IBVSCalculator  bvscalc;
	 
	 public void CalculateLocation(Location loc)
	 {
	     var val = mapper.MapToValuation(loc);
		 bvscalc.CalculateValuation(val);
		 var loc = mapper.MapToLocation(val);
		 return loc;
	 }
  }
  
  6. Bridge pattern
      
       ----------------                                      ------------------  
      | IAbstraction   |                                    | IImplementation  |
	  |----------------|                                    |------------------| 
      | SomeMethod()   |                                    | Method()         |  
       ----------------                                      ------------------
             ^                                                       ^
             |                                                       | 
       ---------------------                                   ------ ----------
      | ConcreteAbstraction |                                 |                 |
      |---------------------|                       -----------------    -----------------
	  | implementator       |-<>-----------------> | ImplementationA |  | ImplementationB |
	  | SomeMethod()        |                      |-----------------|  |-----------------| 
	   ---------------------                       | Method()        |  | Method()        | 
	    |                                            -----------------    -----------------
	    |
	    |-----------> implementator.Method()
  	   
  7. Composite pattern
            -------------------  
           |  Component	       |
	       |-------------------| 
		   | Operation()       |
	       | Add(Component)    |
		   | Remove(Component) |
		   | GetChild(i)       |
		    -------------------
			       ^
			       |
		   -------- ------------ 
	      |                     |
          |                     |
     ---------------     --------------------------
    |   Leaf	    |   | Composite                |   
	|---------------|   |--------------------------|
    | Operation()   |   | List<Component> children | 
     ---------------	| Add(Component)           | 
	                    | Remove(Component)        |
	                    | GetChild(i)              |
						| Operation()              |--------> for each child from children call child.Operation() 
						 --------------------------
						 
    In chup we have different group types. And some groups can have subgroups. 
	This pattern is applicable here.
	
  8. Decorator pattern   or wrapper
       --------------------
      |  Component         | 
      |--------------------|
      | Operation()        |
	   --------------------
	          ^   ^
	          |   | 
			  |    --------------------------------------
	   ---------------------                             |
	  |  ConcreteComponent  |                            |
	  |---------------------|             ---------------------
	  | Operation()         |            |  Decorator          |
	   ---------------------             |-------------------- |
	                                     | Component component | 
										 | Operation()         | 
										  ---------------------
										            ^
										            |
										  ---------- ------------
										 |                       |
								-------------------      ----------------------		 
							   |  StateDecorator   |    |  BehaviourDecorator  |			 
							   |-------------------|    | ---------------------|
							   | Operation()       |    |  AddBehaviour()      |       
							   | addedState        |    |  Operation()         | --<>----> call AddBehaviour(). 			  
							    -------------------		 ----------------------	  
	We have scroll decorator and border decorator.
    Example for IBuildingCalculator 
	We have BuildingCalculatorBase which calculates the base building's cost.
	We should have a decorator which applies climate factor, hillside factor and soil condition
	to IBuildingCalculator.
	We have BuildingCalculatorUpdateTotalsDecorator which updates Totals object with calculated 
	values.
	
	Decorator wrapper can be applied to different interfaces.
	 
  9.  Facade pattern 
 	                     ---------- 
					    | Facade   |---------------  
						 ----------	               |
          subsystem1  		|| 					   |
          ---------  	    ||      subsystem2     |subsystem3
         |_________|    ---- |      --------       ----------
              ^        |      -----|________|     |__________|
	          |        |
	   ------    -------	  
	  |______|  |_______|   
	  
	 Facade creates a common interface for different subsystems
	 For example a compiler consists of 3 different subsystems:
	 parser, code generator, scanner.
	 ICompilerFacade unates all these systems and hide private 
	 subsystems from a client.
	 
	 In CHUP we also have ICalculatorFacade that unates 
	 sevaral different calculation parts.
	  
  10. Flyweight pattern
     Another name is a pool of objects.
	 This pattern's application is to create a cache of objects.
     We can find an object by its key inside this pool.	
  
      --------------                               ----------------------    
     | Flyweight    |<---------------------<>-----| FlyweightFactory     |
     |--------------|                             |----------------------|
	 |              |                             | flyweights           |
	 | Operation()  |                             | CreateFlyweight(key) | --  
	 | state        |                              ----------------------    |
	  --------------                                                         | 
            ^	    	                                 -------------------- 
            |                                            |
			|                                            |
	  -------------------		                         V
	 | ConcreteFlyweight |		            ------------------------------  
	 |-------------------|                 | if flyweights[key] != null   |       
	 | Operation()       |                 |    return flyweights[key];   |
	 | state             |                 | else                         |
	  -------------------                  |    create new flyweight      |
	                                       |    add to flyweights         |
	                                       |    return this flyweight     | 
	                                        ------------------------------
    In CHUP calculation we have cached all material costs
    By material key we can find all information about this material.
    all costs.	
  
   11. Proxy pattern
    It has the same interface as a real object. 
	It is used for:
	 a) Calculate an object's references.
	 b) To postpone real load of element later if it is expensive
	 c) To hide requests to a remote object. Hide inward network communication.
	 
	  --------           ----------- 
	 | Client |-------> | Subject   |
	 |        |         | Request() |  
	  --------           -----------
                             ^	  
	                         |
	                         |
						 -------------                          ----------------------
						| RealSubject | <-----------<>---------| Proxy                |    
	                    | Request()   |                        |----------------------|   
	                     -------------                         | RealSubject _subject |
	                                                     ------| Request()            |
	                                                    |       ----------------------
	                                                    |
	                                                    V
                                             ----------------------- 
                                            | if (_subject)         |
                                            |   _subject = request to real subject
                                              return _subject.											
	
	
	In chup we have a storage service using which we can save pictures into a database
	We can read a picture from a database and can load thumbnails.
	We have created a provider which is a proxy for a storage service and 
	it hides an inward requests and responses that are sent to the storage service.
	And it also can cache a thumbnails.
	
   12. Chain of responsibility.
    This pattern is applied for requests processing.
	For each request type we have a separate handler which 
	can only process that type of requests. It skips other requests.
	Each request handler has a link to the next handler so that they are
	united into a chain and a client keeps a link only to the first element 
	of this chain. Client doesn't know about all handlers.
	
	 ---------                        ------------    --
	| Client  |---<>------------->   |   Handler  |<-|  |
	|         |                      |   next     |-----
     ---------                        ------------
     ----------                            ^
	| Request  |                           |
	 ----------                     ------- ----------
	                               |                  |
	                       ------------------      ------------------    
 	                      | ConcreteHandler1 |    | ConcreteHandler2 |
	                       ------------------      ------------------ 
	In CHUP it is used for Controller's commands processing.
	
   13. Command pattern.
      
     ----------	                  ------------
    | Client   |	             | Command    |
     ----------                  |------------| 
	                             | Execute()  |
                                 | Undo()     |								 
	 ----------                   ------------ 
	| Receiver |<--                   ^
	 ----------    |                  | 
	               |             ------------------  
	               |            | ConcreteCommand  |
	               |            |------------------|  
	               |            | state            |
	                ------------| receiver         |
	                            | Execute()        | 
								| Undo()           |
								 ------------------
								 
	In CHUP every button is asociated with a command.
	From UI we send a request to a controller and then the controller
	executes some command.
	
	
   14. Interpretator
	
	 ---------                          --------------
	| Client  |                        | Expression   | 
	|         |                        | context      | <----
	|         |                        | Interpret()  |      |       
	 ---------                          --------------       |
	 ---------                                ^               --------------
	| Context |                               |                             | 
	 ---------                                |                             |
	                               ----------- ------------                 |
								  |                        |                |
                           ---------------          ----------------        |
						  |	TerminalEx	  |        | NonTerminal    |       |
                          | Interpret()   |        | Interpret()    |       |
						   ---------------         | expressions    |--<>--- 
						                            ----------------
	We can create an expression tree.
	We have a boolean expression
	
	(true and x) or (y and (not x))
	
	var exp_x = new VariableExpression('X');
	var exp_y = new VariableExpression('Y');
	
	var totExp = new OrExpression(
	   new AndExpression(new ConstantExpr(true), exp_x),
       new AndExpression(exp_y, new NotExpr(exp_x));	   
	);
	
	context.Assign(exp_x, true);
	context.Assign(exp_y, false);
	
	totExp.Interpret();
    	
	It is used for NHibernate criteria.
	
	List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();

    Lambda expressions also are implemented through interpretator pattern.
	
    15. Iterator

      -----------------                 ----------------
     | Aggregate       |               |   Iterator     |	 
	 |-----------------|               |----------------|
	 | Add(item)       |               | aggregate      |
     | Remove(item)    |	           | First()        |
	 | GetByIndex(ind) | 			   | Prev()         |	 
	 | GetIterator()   |               | Next()         |
	  -----------------				   | IsDone()       |					   			
            ^						    ----------------
            |                                  ^
			|			                       |
      -------------------			   ------------------        
     | ConcreteAggregate | <-------<>-| ConcreteIterator | 
	 | GetIterator()     |		      |------------------|
	  -------------------             | aggregate        | 
						               ------------------
									   
	 IEnumerable is an application of this pattern in .NET
	 
	16. Mediator
	
	 ----------                        --------------- 
	| Mediator |                      |   Colleage    |     
	|          |                      | mediator      |  
	 ----------                        --------------- 
	     ^                                   ^ 
	     |                                   |
   ------------------               --------- ------------
  | ConcreteMediator |   		   |                      |
  |------------------|      -------------------     --------------------
  | colleage1        |---->| ConcreteColleage1 |   | ConcreteColleage2  |
  | colleage2        |--    -------------------     --------------------
   ------------------   |                               ^
                         -------------------------------
						 
	Model View Presenter is an implementation of mediator pattern.
	
	
    17. Memento pattern.
   -------------------------                       ---------------------
  | Originator              |--<>---------------> | Memento             | 
  | SetMemento(Memento mem) |                     | State state         |
  | GetMemento()            |                     | GetState()          |
   -------------------------                      | SetState(State)     | 
                                                   ---------------------
												   
    18. Observer pattern.
   
   ------------------ 
  | Subject		     | 							    ----------------------	    
  |------------------|                             | Observer             |
  | observers        | ---<>---------------------->|----------------------|
  | NotifyObservers()|                             | Subject subject      |   ----------------------------
   ------------------                              | Update()             |--| Update the subject's state |
    |                                               ----------------------    ----------------------------
	|           -----------------------
	|--------->| foreach all observers |  
	           |  observer.Update()    |
			    -----------------------

    19. State pattern.

	 --------------                                  ---------------
    | Context      |--<>----------------------->    |  State        |
    |--------------|                                |---------------|
	| state        |                                | moveToNext()  |
	| operation()  |                                | operation()   |
	 --------------                                  ---------------
	 |                                                     ^
	 |     -------------------                             |
	  --->| state.operation() |                            |
	       -------------------                    --------- ---------
                                                 |                   |  	  
	                                             |                   |
	                                   ------------------        ------------------
	                                  | ConcreteStateA   |      |  ConcreteStateB  |
	                                  |------------------|      |------------------|
                                      | moveToNext()     |      | moveToNext()     |
                                      | operation()      |      | operation()      |
                                       ------------------        ------------------
									  

	20. Strategy.

     --------------                      --------------
    | Context      |----<>----------->  | Strategy     |									  
    |--------------|                    |--------------|
    | strategy     |	                | operation()  |
	| operation()  | 					 --------------			   
     --------------                          ^
	                                         |
                                             |
                                   ---------- ----------------
                                  |                           |
                            -------------------       -------------------
						   | ConcreteStrategyA |     | ConcreteStrategyB |
						   |-------------------|	 |-------------------|				  
						   |  operation()      |	 | operation()       |
							-------------------		  -------------------		  
	
	21. Template methods.
	
	Define the skeleton of an algorithm in an operation, deferring somesteps to
    subclasses. Template Method lets subclasses redefinecertain steps of an algorithm
    without changing the algorithm'sstructure.
	
	 -----------------------
	| Base Class            |
	|-----------------------|
	| TemplateMethod()      |---
	| abstract Operation1() |   |
	| abstract Operation2() |   |
	|-----------------------|   | 
	     ^                      |
	     |                      V
	     |       ------------------ 
	     |      | call operation1  |
         |      | call operation2  |
         |		 ------------------   				
	     |               ---------------------
	     |              |  Derived class      |
	      ------------- |-------------------- |
	                    | Operation1()        |
	                    | Operation2()        |
						 ---------------------
	
	22. Visitor.
	
	Represent an operation to be performed on the elements of an objectstructure.
    Visitor lets you define a new operation without changing theclasses of the elements
    on which it operates.
	
	We have a tree and a lot of nodes and we want to add a lot of new methods
	which is too complicated. So we want to separate this code from the nodes.
	             ----------------
	            |   BaseNode     |
				} ---------------|
				| TypeCheck()    |
				| GenerateCode() |
	            | PrettyPrint()  |
				 ----------------
	                    ^
						|
						|
			 /----------- -------------\ 			
		    V				            V
	 ----------------            ------------------   
	| VariableRefNode|          | AssignmentNode   |   
	} ---------------|          |------------------|
	| TypeCheck()    |          |
	| GenerateCode() |
	| PrettyPrint()  |
     ----------------					

       We can have both by packaging related operations from each class in aseparate
    object, called a visitor, and passing it to elements of the abstract syntax tree
    as it's traversed. 
	
	   When an element"accepts" the visitor, it sends a request to
    the visitor that encodes the element's class. It also includes the element as an
    argument. The visitor will then execute the operation for that element—theoperation
    that used to be in the class of the element.	 
	
	
	
    20. Give an example where you prefer abstract class over interface ?

    1. In Java you can only extend one class but implement multiple interface. 
	   So if you extend a class you lost your chance of extending another class.

	2. Interface are used to represent adjective or behavior e.g. Runnable, Clonable, Serializable etc, 
	   so if you use an abstract class to represent behavior 
	   your class can not be Runnable and Clonable at same time 
	   because you can not extend two class in Java 
	   but if you use interface your class can have multiple behavior at same time.
	   
	3. On time critical application prefer abstract class is slightly faster than interface.

    4. If there is a genuine common behavior across the inheritance hierarchy 
	   which can be coded better at one place than abstract class is preferred choice. 
	   Some time interface and abstract class can work together also 
	   where defining function in interface and default functionality on abstract class.
    
	5. Got the following statement from an MSDN article. 
	   It says that the abstract classes have an advantage over interfaces 
	   because it is possible to alter an abstract class to add new members. 
	   
	   
    
	21. Design a Vending Machine which can accept different coins, deliver different products?
	
    22. Why is access to non-static variables not allowed from static methods in Java?
	
       You can not access non-static data from static context in Java 
	   simply because non-static variables are associated with 
	   a particular instance of object while Static is not associated with any instance. 
	   You can also see my post why non static variable are not accessible in static context for more detailed discussion.

    23. What is design patterns ? Have you used any design pattern in your code ?
	
       Design patterns are tried and tested way to solve particular 
	   design issues by various programmers in the world. 
	   Design patterns are extension of code reuse.
    
    24. What is the difference between Factory and Abstract Factory?
	
	   
    25. When to use Strategy Design Pattern in Java?
	
       Strategy pattern in quite useful for implementing 
	   set of related algorithms e.g. compression algorithms, 
	   filtering strategies etc. 
	   Strategy design pattern allows you to create Context classes, 
	   which uses Strategy implementation classes for applying business rules. 
	   This pattern follow open closed design principle and quite useful in Java. 
	   One example of Strategy pattern from JDK itself is a Collections.sort() 
	   method and Comparator interface, 
	   which is a strategy interface and defines strategy for comparing objects. 
	   Because of this pattern, we don't need to modify sort() method 
	   (closed for modification) to compare any object, 
	   at same time we can implement Comparator interface to define new comparing strategy (open for extension).

    26. What is Observer design pattern in Java? When do you use Observer pattern in Java?
	
	27. Difference between Strategy and State design Pattern in Java?
	
       This is an interesting Java design pattern interview questions 
	   as both Strategy and State pattern has same structure. 
	   If you look at UML class diagram for both pattern 
	   they look exactly same, but there intent is totally different. 
	   State design pattern is used to define and mange state of object, 
	   while Strategy pattern is used to define a set of interchangeable algorithm 
	   and let's client to choose one of them. 
	   So Strategy pattern is a client driven pattern while Object can manage there state itself.
	   
	28. What is decorator pattern in Java? Can you give an example of Decorator pattern?   
	
	   class Stream
	   {
          void ReadByte();	   
	   }
	   
	   class FileStream : Stream
	   {
          void ReadByte();	   	   
	   }
	   
	   class NetworkStream : Stream
	   {
	      void ReadByte();	   	   
	   }
	
       class BufferStream : Stream
	   {
	      Stream inwardStream;

          public BufferStream(Stream stream)
          {
		     inwardStream = stream;
		  }		  
		  
		  override void ReadByte();	 // substitute ReadByte method  	   
	   }
	   
	   class CryptoStream : Stream
	   {
	      Stream inwardStream;

          public CryptoStream(Stream stream)
          {
		     inwardStream = stream;
		  }		  
		  
		  override void ReadByte();	 // substitute ReadByte method  	   
	   }
	   
	29. When to use Composite design Pattern in Java? Have you used previously in your project?
	
    This design pattern question is asked on Java interview not just 
	to check familiarity with Composite pattern but also, 
	whether candidate has real life experience or not. 
	Composite pattern is also a core Java design pattern, 
	which allows you to treat both whole and part object to treat in similar way. 
	Client code, which deals with Composite or individual object doesn't differentiate on them, 
	it is possible because Composite class also implement same interface as there individual part. 
	One of the good example of Composite pattern from JDK is JPanel class, 
	which is both Component and Container. 
	
    30. Other patterns application in .NET Framework.
	
	Abstract Factory : 
	    System.Data.Common.DbProviderFactory. Every member function of this class is a factory method
		
	Builder : 
	    The WCF channel construction infrastructure
	
    Factory Method : 
	    System.Data.IDbConnection.BeginTransaction(). 
		The type of transaction created depends on the underlying IDbConnection implementation.
	
	Adapter : 
	    The ADO.NET providers, eg System.Data.SqlClient.SqlConnection,
	
    Composite : 
	    many examples:
        System.Windows.Forms.Control and its derived classes.
        System.Web.UI.Control and its derived classes.
        System.Xml.XmlNode and its derived classes.
									  
	Facade : 
	    System.Xml.Serialization.XmlSerializer. 
		XmlSerializer hides a complex task (that includes generating assemblies on the fly!) 
		behind a very easy-to-use class.								  
									
	Chain of Responsibility : 
	    System.Web.UI.Control.OnBubbleEvent() and System.Web.UI.Control.RaiseBubbleEvent().
    
    Command : 
	    System.Windows.Input.ICommand (in WPF)
    
    Interpreter : 
	    System.Linq.Expressions.Expression and related classes.

    Iterator : 
	    many examples :
        System.Collections.IEnumerable.
        System.Collections.Generic.IEnumerable<T>.
        System.Data.IDataReader.
		
    Memento : 
	    The .NET Serializable pattern is a variation on the Memento pattern.
		
    Observer : 
	    The .NET event mechanism.
		
    Strategy : 
	    Microsoft.Practices.EnterpriseLibrary.ExceptionHandling.ExceptionPolicy 
		and related classes (ok it's not in the framework itself).
		
    Visitor : 
	    System.Linq.Expressions.ExpressionVisitor (used internally by LINQ).

		
		
	30. When to use Template method design Pattern in Java?
	
	Template pattern is another popular core Java design pattern interview question. 
	I have seen it appear many times in real life project itself. 
	Template pattern outlines an algorithm in form of template method 
	and let subclass implement individual steps. 
	Key point to mention, while answering this question is that template method should be final, 
	so that subclass can not override and change steps of algorithm, 
	but same time individual step should be abstract, so that child classes can implement them.

	31. What is Factory pattern in Java? 
	    What is advantage of using static factory method to create object?
		
	32. Difference between Decorator and Proxy pattern in Java?	
	
	Another tricky Java design pattern question and trick here is 
	that both Decorator and Proxy implements interface 
	of the object they decorate or encapsulate. 
	As I said, many Java design pattern can have similar 
	or exactly same structure but they differ in there intent. 
	Decorator pattern is used to implement functionality on 
	already created object, 
	while Proxy pattern is used for controlling access to object. 
	One more difference between Decorator and Proxy design pattern is that, 
	Decorator doesn't create object, 
	instead it get object in it's constructor, while Proxy actually creates objects.
	
	33. When to use Setter and Constructor Injection in Dependency Injection pattern?
	
	Construction injection drawbacks:
	
	1. No reconfiguration and re-injection
	
	So indeed, using constructor injection when no setters exist, 
	you cannot reconfigure the constructed bean by injecting new dependencies into it.
    If you want to “reconfigure” the bean, 
	you’ll have to construct a new bean instance using 
	the new dependencies and discard the other one.
	
	2.  
	
	While it’s not a recommended scenario, 
	you could create a circular dependency using Spring. 
	But not by using constructor-based injection. 
	If you want to create a circular dependency, 
	you’ll have to use setter-based injection.
	
	
	34. When to use Adapter pattern in Java? Have you used it before in your project?
	
	Use Adapter pattern when you need to make two class work with incompatible interfaces. 
	Adapter pattern can also be used to encapsulate third party code, 
	so that your application only depends upon Adapter, 
	which can adapt itself when third party code changes 
	or you moved to a different third party library. 
	By the way this Java design pattern question 
	can also be asked by providing actual scenario.
	
	
	35 Can you write code to implement producer consumer design pattern in Java?
	
	A producer/consumer queue is a common requirement in threading. Here’s how it works:
    A queue is set up to describe work items — or data upon which work is performed.
    When a task needs executing, it’s enqueued, allowing the caller to get on with other things.
    One or more worker threads plug away in the background, picking off and executing queued items.

	class ProducerConsumerQueue : IDisposable
    {
       EventWaitHandle _wh      = new AutoResetEvent (false);
       Thread          _worker;
	   
       readonly object _locker  = new object();
       Queue<string> _tasks     = new Queue<string>();
	   
	   public ProducerConsumerQueue()
       {
           _worker = new Thread(Work);
           _worker.Start();
       }
	   
	   public void EnqueueTask (string task)
       {
            lock (_locker) 
			{
			   _tasks.Enqueue (task);
			}
			
            _wh.Set();
       }
	   
	   void Work()
       {
           while (true)
           {
               string task = null;
			   
               lock (_locker)
			   {
                   if (_tasks.Count > 0)
                   {
                       task = _tasks.Dequeue();
                       if (task == null) 
					       return;
                   }
			   }
				   
               if (task != null)
               {
                   Console.WriteLine ("Performing task: " + task);
                   Thread.Sleep (1000);  // simulate work...
               }
               else
                   _wh.WaitOne();         // No more tasks - wait for a signal
           }
        }
		
		public void Dispose()
        {
            EnqueueTask (null);     // Signal the consumer to exit.
            _worker.Join();         // Wait for the consumer's thread to finish.
            _wh.Close();            // Release any OS resources.
        }
    }
	
	
 AutoReset Event
 
 It is applied to send messages among threads.
 From start is in unsignalled state:  new AutoResetEvent(false)
 Run several threads: 
 In each thread start waiting AutoResentEvent.WaitOne().
 All threads are waiting for event.
 The main thread runs AutoResetEvent.Set()
 It wakes up only one thread and becomes unsignalled again.
 
 
    16. What is Open closed design principle in Java? 
	
	
	Open closed design principle is one of the SOLID principle defined by Robert C. Martin, 
	popularly known as Uncle Bob. 
	This principle advices that a code should be open for extension but close for modification. 
	At first this may look conflicting but once you explore power of polymorphism, 
	you will start finding patterns which can provide stability and flexibility of this principle. 
	One of the key example of this is State and Strategy design pattern, 
	where Context class is closed for modification 
	and new functionality is provided by writing new code by implementing new state of strategy. 
	See this article to know more about Open closed principle.
    
	
	In Simple language Open closed design principles says 
	that new functionality should be added by introducing new classes, 
	methods or fields instead of modifying already tried and tested code. 
	
	One of the way to achieve this is Inheritance 
	where class is extended to introduce 
	new functionality on top of inherited basic features.

    Benefit or Open Closed Design Principle:
	
    1) Application will be more robust because we are not changing already tested class.
    2) Flexible because we can easily accommodate new requirements.
    3) Easy to test and less error prone.

    Basic principle of making your code extensible 
	and following open closed principle is providing object to class at run time 
	and making use of polymorphism to invoke extended functionality.
	
    If functionality is hard Coded than it wouldn’t be extensible 
	but if you write interface and provide implementation 
	of that interface at run time you make it extensible.

	In object-oriented programming, the open/closed principle states 
	"software entities (classes, modules, functions, etc.) should be open for extension, 
	but closed for modification";
	
	[1] that is, such an entity can allow its behaviour to be modified without altering its source code. 
	This is especially valuable in a production environment, 
	where changes to source code may necessitate code reviews, unit tests, and other such procedures 
	to qualify it for use in a product: 
	code obeying the principle doesn't change when it is extended, and therefore needs no such effort.
	
	The name open/closed principle has been used in two ways. 
	Both ways use inheritance to resolve the apparent dilemma, 
	but the goals, techniques, and results are different.
	
	The idea was that once completed, the implementation of a class 
	could only be modified to correct errors; 
	new or changed features would require that a different class be created. 
	That class could reuse coding from the original class through inheritance. 
	The derived subclass might or might not have the same interface as the original class.
	
    Meyer's definition advocates implementation inheritance. 
	Implementation can be reused through inheritance 
	but interface specifications need not be. 
	The existing implementation is closed to modifications, 
	and new implementations need not implement the existing interface.
	
	During the 1990s, the open/closed principle became popularly redefined 
	to refer to the use of abstracted interfaces, 
	where the implementations can be changed and multiple implementations 
	could be created and polymorphically substituted for each other.
	
    In contrast to Meyer's usage, this definition advocates inheritance from abstract base classes. 
	Interface specifications can be reused through inheritance but implementation need not be. 
	The existing interface is closed to modifications and new implementations must, 
	at a minimum, implement that interface.
	

   36. 	What is Builder design pattern in Java? When do you use Builder pattern?
  
    Builder pattern in Java is another creational design pattern in Java 
	and often asked in Java interviews because of its specific use 
	when you need to build an object which requires multiple properties some optional and some mandatory. 
	See When to use Builder pattern in Java for more details.
	
	As I said earlier Builder pattern is a creational design pattern it means 
	its solves problem related to object creation. 
	Constructors in Java are used to create object 
	and can take parameters required to create object. 
	
	Problem starts when an Object can be created with lot of parameters, 
	some of them may be mandatory and others may be optional. 
	Consider a class which is used to create Cake, 
	now you need number of item like egg, milk, flour to create cake. 
	many of them are mandatory and some  of them are optional like cherry, fruits etc. 
	If we are going to have overloaded constructor for different kind of cake 
	then there will be many constructor and even worst they will accept many parameter.

	Problems:
    1) too many constructors to maintain.
    2) error prone because many fields has same type e.g. sugar 
	   and and butter are in cups so instead of 2 cup sugar 
	   if you pass 2 cup butter, your compiler will not complain 
	   but will get a buttery cake with almost no sugar with high cost of wasting butter.
    
	You can partially solve this problem by creating Cake 
	and then adding ingredients but that will impose 
	another problem of leaving Object on inconsistent state during building, 
	ideally cake should not be available until its created. 
	
	Both of these problem can be solved by using Builder design pattern in Java. 
	Builder design pattern not only improves readability but also reduces 
	chance of error by adding ingredients explicitly 
	and making object available once fully constructed. 

	Examples in .NET: 
	

string connectionString = new SqlConnectionStringBuilder
{
    DataSource = "localhost",
    InitialCatalog = "MyDatabase",
    IntegratedSecurity = true,
    Pooling = false
}.ConnectionString;


   
   37. Can you give an example of  SOLID design principles in .NET?
   
   1. DRY (Don't repeat yourself)
   
      Our first object oriented design principle is DRY, 
	  as name suggest DRY (don't repeat yourself) 
	  means don't write duplicate code, 
	  instead use Abstraction to abstract common things in one place. 
	  If you have block of code in more than two place consider making it a separate method, 
	  or if you use a hard-coded value more than one time make them public final constant.
   
   2. Encapsulate What Changes
   
      Only one thing is constant in software field and that is "Change", 
	  So encapsulate the code you expect or suspect to be changed in future. 
	  Benefit of this OOPS Design principle is that 
	  Its easy to test and maintain proper encapsulated code. 
	  If you are coding in Java then follow principle of making variable 
	  and methods private by default and increasing access step by step e.g. 
	  from private to protected and not public.
   
   3. Open Closed Design Principle.
      
	  Classes, methods or functions should be Open for extension (new functionality) 
	  and Closed for modification. This is another beautiful SOLID design principle, 
	  which prevents some-one from changing already tried and tested code. 
	  Ideally if you are adding new functionality only than your code 
	  should be tested and that's the goal of Open Closed Design principle. 
	  By the way, Open Closed principle is "O" from SOLID acronym.
      
	  
   4. Single Responsibility Principle (SRP)
   
      Single Responsibility Principle is another SOLID design principle, 
	  and represent  "S" on SOLID acronym. 
	  As per SRP, there should not be more than one reason for a class to change, 
	  or a class should always handle single functionality. 
	  If you put more than one functionality in one Class in Java  
	  it introduce coupling between two functionality and even 
	  if you change one functionality there is chance you broke coupled functionality,  
	  which require another round of testing to avoid any surprise on production environment.

    5. Dependency Injection or Inversion principle.
	
	  Don't ask for dependency it will be provided to you by framework. 
	  This has been very well implemented in Spring framework, 
	  beauty of this design principle is 
	  that any class which is injected by DI framework 
	  is easy to test with mock object 
	  and easier to maintain because object creation code is centralized in framework 
	  and client code is not littered with that.
	  There are multiple ways to  implemented Dependency injection 
	  like using  byte code instrumentation which some AOP (Aspect Oriented programming) framework 
	  like AspectJ does or by using proxies just like used in Spring. 
	  See this example of IOC and DI design pattern to learn more about this SOLID design principle. It represent "D" on SOLID acronym.

      As name suggest Inversion of control pattern 
	  Inverts responsibility of managing life cycle of object e.g. creating object, 
	  setting there dependency etc from application to framework, 
	  which makes writing Java application even more easy.
	  
	  Programmer often confused between IOC and DI, 
	  well both words used interchangeably in Java world 
	  but Inversion of Control is more general concept 
	  and Dependency Injection is a concrete design pattern. 

      Dependency Injection is a design pattern on which dependency of object 
	  (in this case AuditDAO is a dependency for AuditServiceImpl Object) 
	  is injected by framework rather than created by Object itself. 
	  Dependency Injection reduces coupling between 
	  multiple object as its dynamically injected by framework.
      
      In Constructor Injection, dependency of Object is injected using constructor, 
	  while in Setter Injection, Dependency is provided by setter method. 
	  Both has there pros and cons. Constructor DI allows object to be created 
	  in complete state and follows principle of fully functional object 
	  while Setter DI allows object to be created without its dependency. 
	  which may result in incomplete object if dependency is not available.

      1) Reduce coupling
      both constructor and setter dependency injection reduce coupling. 
	  like in above example coupling between AuditService and AuditDAO is reduced by using Dependency Injection.

      2) Improves testability
      Dependency Injection allows to replace actual object with mock object 
	  which improves testability by writing simple JUnit tests which uses mock object.

	  3) Flexibility
      This is another advantage which comes as side benefit of reduced coupling, 
	  because of DI you can replace non performance implementation with better one later.
	  
	  Most readers will be familiar with Bob Martin's famous dependency inversion principle, which states -
	  
      High-level modules should not depend on low-level modules. 
	  Both should depend on abstractions
      Abstractions should not depend upon details. 
	  Details should depend upon abstractions.
	  
	  What he's saying here is that you should avoid a scenario 
	  where a base class takes a dependency to meet the need of a descendant. 
	  Let's look at the case of a Switch and its descendant the TimedSwitch. 
	  The TimedSwitch is a Switch that resets itself after a certain amount of time. 
	  We have the TimedObject class already so 
	  it would make sense for TimedSwitch to derive from it...
	  however TimedSwitch already derives from Switch. 
	  So in order to meet the needs of the TimedSwitch, 
	  Switch will inherit from TimedObject even though 
	  it doesn't need that functionality itself.
	  
	  
	  
   6. Favor Composition over Inheritance.
   
      Always favor composition over inheritance ,if possible. 
	  Some of you may argue this, but I found that Composition is lot more flexible than Inheritance. 
	  Composition allows to change behavior of a class at runtime 
	  by setting property during runtime and by using Interfaces 
	  to compose a class we use polymorphism 
	  which provides flexibility of to replace with better implementation any time. 
	  Even Effective Java advise to favor composition over inheritance.

   7. Liskov Substitution Principle (LSP).
      
	  According to Liskov Substitution Principle, 
	  Subtypes must be substitutable for super type 
	  i.e. methods or functions which uses super class type 
	  must be able to work with object of sub class without any issue". 
	  
	  LSP is closely related to Single responsibility principle and Interface Segregation Principle. 
	  If a class has more functionality than subclass might not support some of the functionality ,
	  and does violated LSP. 
	  
	  In order to follow LSP SOLID design principle, 
	  derived class or sub class must enhance functionality, 
	  but not reduce them. LSP represent  "L" on SOLID acronym.

      Motivation

      All the time we design a program module and we create some class hierarchies. 
	  Then we extend some classes creating some derived classes.
      We must make sure that the new derived classes just extend 
	  without replacing the functionality of old classes. 
	  Otherwise the new classes can produce undesired effects 
	  when they are used in existing program modules.
	  
	  A derived class should only extend and supplement the base's class functionality,
	  not make it narrower or change it. So that the derived class can be put in place of 
	  the base class in a client's code and it will work.
	  
	  So is we have written test for some functionality which depends on the base class.
	  Now we create a derived class and override some methods which affects and changes other 
	  base functionality. In this case the test will fail.
	  
	  The Switch (abstraction) is dependent on the details of TimedSwitch. 
	  To fix this violation of the DIP, we have TimedSwitch 
	  implement ITimedObject and delegate to a contained 
	  TimedObject class (prefer composition over inheritance).
	  
	public class Rectangle
    {
        protected int _width;
        protected int _height;
        public int Width
        {
            get { return _width; }
        }
        public int Height
        {
            get { return _height; }
        }

        public virtual void SetWidth(int width)
        {
            _width = width;
        }
        public virtual void SetHeight(int height)
        {
            _height = height;
        }
        public int getArea()
        {
            return _width * _height;
        }
    }

    public class Square : Rectangle 
    {
        public override void SetWidth(int width)
        {
            _width = width;
            _height = width;
        }

        public override void SetHeight(int height)
        {
            _height = height;
            _width = height;
        }
    }  
	  
	  
            var square = new Square();
            square.SetHeight(10);
            square.SetWidth(5);
            var area1 = square.getArea(); // Should be 5 * 5

            var rectangle = (Rectangle)square;
            rectangle.SetHeight(10);
            rectangle.SetWidth(5);
            var area12 = square.getArea(); // Should be 10 * 5

            // Square is a rectangle. So when we convert Square type
            // to Rectangle type it should behave like a rectangle
    
	
	8. Interface Segregation principle (ISP).
				
	Interface Segregation Principle stats that, 
	a client should not implement an interface, if it doesn't use that. 
	This happens mostly when one interface contains more than one functionality, 
	and client only need one functionality and not other.
	Interface design is tricky job because once you release your interface 
	you can not change it without breaking all implementation. 
	Another benefit of this design principle in Java is, 
	interface has disadvantage to implement all method 
	before any class can use it so having single functionality means less method to implement.

    The interface-segregation principle (ISP) states 
	that no client should be forced to depend on methods it does not use.[1] 
	ISP splits interfaces which are very large into smaller 
	and more specific ones so that clients will only have to know about the methods 
	that are of interest to them. 
	Such shrunken interfaces are also called role interfaces.[2] 
	ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy. 	
			
    Within object-oriented design, interfaces provide layers of abstraction 
	that facilitate conceptual explanation of the code 
	and creates a barrier preventing dependencies.
	
    According to many software experts who have signed the Manifesto for Software Craftsmanship, 
	writing well crafted and explanatory software is almost as important as writing working software.[4] 
	Using interfaces to further describe the intent of the software is often a good idea.
    It is also true that a system may become so coupled with a lot of levels 
	so that it is no longer possible to make a change in one place 
	without having a ripple effect throughout the design, 
	having to make subsequent changes in many places.[1] 
	Using an interface or an abstract class can prevent this side effect.
			
			
    9. Programming for Interface not implementation.
	  
	Always program for interface and not for implementation this will lead to flexible code 
	which can work with any new implementation of interface. 
	So use interface type on variables, 
	return types of method or argument type of methods in Java. 
	This has been advised by many Java programmer including in Effective Java and head first design pattern book.

    
	10. Delegation principle.
	
	Don't do all stuff  by yourself,  delegate it to respective class. 
	Classical example of delegation design principle is equals() and hashCode() method in Java. 
	In order to compare two object for equality 
	we ask class itself to do comparison instead of Client class doing that check. 
	Benefit of this design principle is no duplication of code and pretty easy to modify behavior.

    11. What is difference between Abstraction and Encapsulation in Java?
	
	Abstraction represent taking out the behavior from How exactly its implemented, 
	one example of abstraction in Java is interface 
	while Encapsulation means hiding details of implementation 
	from outside world so that when things change no body gets affected
    
	
    38. What does polymorphism mean?
	
	
	In programming languages and type theory, polymorphism is the provision 
	of a single interface to entities of different types.
	  
    | one common interface | is implemented by many implementations.
	  
    So polymorphism is the ability (in programming) to present 
	the same interface for differing underlying forms (data types).
	
	For example, integers and floats are implicitly polymorphic 
	since you can add, subtract, multiply and so on, 
	irrespective of the fact that the types are different. 
	They're rarely considered as objects in the usual term.
     
    But, in that same way, a class like BigDecimal or Rational or Imaginary 
	can also provide those operations, even though they operate on different data types.  
   
    The classic example is the Shape class and all the classes 
	that can inherit from it (square, circle, dodecahedron, irregular polygon, splat and so on)
    
	With polymorphism, each of these classes will have different underlying data. 
	A point shape needs only two co-ordinates 
	(assuming it's in a two-dimensional space of course). 
	A circle needs a center and radius. 
	A square or rectangle needs two co-ordinates for the top left 
	and bottom right corners (and possibly) a rotation. 
	An irregular polygon needs a series of lines.
    
    And, by making the class responsible for its code as well as its data, 
	you can achieve polymorphism. 
	In this example, every class would have its own Draw() function 
	and the client code could simply do:

    A polymorphic type is a type whose operations can also be applied 
	to values of some other type, or types.[2] 
	There are several fundamentally different kinds of polymorphism:    
	
	1. In programming languages, ad hoc polymorphism[1] is a kind of polymorphism 
	   in which polymorphic functions can be applied to arguments of different types, 
	   because a polymorphic function can denote a number of distinct 
	   and potentially heterogeneous implementations 
	   depending on the type of argument(s) to which it is applied. 
	   It is also known as function overloading or operator overloading. 
	   
	2. If the code is written without mention of any specific type 
	   and thus can be used transparently with any number of new types, 
	   it is called parametric polymorphism. 
	   In the object-oriented programming community, 
	   this is often known as generics or generic programming. 
	   In the functional programming community, this is often simply called polymorphism.
	
	3. Subtyping (or inclusion polymorphism) is a concept 
	   wherein a name may denote instances of many different classes 
	   as long as they are related by some common superclass.[3] 
	   In object-oriented programming, this is often referred to simply as polymorphism.
	
    
	Chris Strachey[4] chose the term ad hoc polymorphism to refer 
	to polymorphic functions which can be applied to arguments of different types, 
	but which behave differently depending 
	on the type of the argument to which they are applied 
	(also known as function overloading or operator overloading). 
	
	program Adhoc;
 
    function Add( x, y : Integer ) : Integer;
    begin
        Add := x + y
    end;
 
    function Add( s, t : String ) : String;
    begin
        Add := Concat( s, t )
    end;
 
    begin
        Writeln(Add(1, 2));
        Writeln(Add('Hello, ', 'World!'));
    end.
	
	Parametric polymorphism is also available in several object-oriented languages, 
	where it often goes under the name "generics" (for example, Java) or "templates" (C++ and D):
	
    Some languages employ the idea of subtyping to restrict the range of types 
	that can be used in a particular case of polymorphism. 
	
	In these languages, subtype polymorphism 
	(sometimes referred to as inclusion polymorphism or dynamic polymorphism[citation needed]) 
	allows a function to be written to take an object of a certain type T, 
	but also work correctly if passed an object that belongs to a type S 
	that is a subtype of T (according to the Liskov substitution principle). 
	This type relation is sometimes written S <: T. Conversely, T is said to be a supertype of S—written T :> S.    
    
	
abstract class Animal {
    abstract String talk();
}
 
class Cat extends Animal {
    String talk() { return "Meow!"; }
}
 
class Dog extends Animal {
    String talk() { return "Woof!"; }
}
 
public class MyClass {
 
    public static void write(Animal a) {
        System.out.println(a.talk());
    }
 
    public static void main() {
        write(new Cat());
        write(new Dog());
    }
 
}
    
	39. What is inheritance mean?
	
  As the name inheritance suggests an object is able 
  to inherit characteristics from another object. 
  In more concrete terms, an object is able to pass on its state 
  and behaviors to its children. 
  For inheritance to work the objects need to have characteristics in common with each other.
 
    40. How does inheritance differ from subtyping?

  We say that A is a subtype of B if all A-typed values 
  can be used in every context 
  where B-typed values are expected. 
  Or, to put another way, A-typed values can "masquerade" as B-typed values.
 
  If such masquerading poses no issues with type checking, i.e., 
  plugging in A-typed values where B-typed values are needed 
  continues to type check, we call it "structural subtyping". 
  
  If it cause no issues with behaviour, i.e., 
  such plugging does not alter the behaviour expected, 
  then we call it "behavioural subtyping". 
  (The "behaviour expected" will have to be formalised separately and many notions of behaviour are possible.)
  
  
  Structural subtyping does not ensure behavioural subtyping 
  because the structure of a type might match for accidental reasons. 
  However, defining the behaviour expected is not easy. 
  So, many programming languages use an intermediate point, 
  where the user has to declare which type is a subtype of which. 
  
  This is referred to as "nominal subtyping". 
  See the question on Implicit vs explicit subtyping for a discussion of this issue. 
  The idea is that the programmer has to ensure behavioural subtyping 
  for all declared subtypes using his own ingenuity. 
  
  The language cannot offer any help. 
  However, all declared subtypes must be at least structural subtypes. 
  Otherwise, the program would fail to type check. 
  The language can help ensure this. 
  (Some programming languages don't have good enough t
   ype systems to ensure this at compile-time. 
   If so, the type failure would be detected at run-time, 
   or perhaps wrong results might be produced. 
   Such type holes are obviously undesirable.)
   

  There are important differences between subtypes and subclasses in supporting reuse. 
  Subclasses allow one to reuse the code inside classes 
  - both instance variable declarations and method definitions. 
  Thus they are useful in supporting code reuse inside a class.   
  
    41. Encapsulation.
	
  In programming languages, encapsulation is used to refer to one of 
  two related but distinct notions, and sometimes to the combination[1][2] thereof:
  
     A language mechanism for restricting access to some of the object's components.[3][4]
     A language construct that facilitates the bundling of data with 
	 the methods (or other functions) operating on that data.[5][6]
  
  Under this definition, encapsulation means that 
  the internal representation of an object is generally hidden 
  from view outside of the object's definition. 
  
  Typically, only the object's own methods can directly inspect or manipulate its fields. 
  Some languages like Smalltalk and Ruby only allow access via object methods, 
  but most others (e.g. C++, C# or Java) offer the programmer 
  a degree of control over what is hidden, typically via keywords like public and private
 
  In general, encapsulation is one of the four fundamentals of OOP (object-oriented programming). 
  Encapsulation is used to hide the values or state of a structured data object inside a class, 
  preventing unauthorized parties direct access to them. 
  Publicly accessible methods are generally provided in the class 
  (so-called getters and setters) to access the values, 
  and other client classes call these methods to retrieve and modify the values within the object
  
    
    42.  ACID versus BASE for database transactions.
	
Database developers all know the ACID acronym. It says that database transactions should be:

Atomic: Everything in a transaction succeeds or the entire transaction is rolled back.
Consistent: A transaction cannot leave the database in an inconsistent state.
Isolated: Transactions cannot interfere with each other.
Durable: Completed transactions persist, even when servers restart etc.

Amazon might instead use cached data. 
Users would not see not the inventory count at this second, 
but what it was say an hour ago when the last snapshot was taken. 
Also, Amazon might violate the “I” in ACID by tolerating a small probability 
that simultaneous transactions could interfere with each other. 

For example, two customers might both believe 
that they just purchased the last copy of a certain book. 
The company might risk having to apologize to one of the two customers 
(and maybe compensate them with a gift card) 
rather than slowing down their site and irritating myriad other customers.
	
	An alternative to ACID is BASE:

Basic Availability
Soft-state
Eventual consistency


    43. How would you (have you?) implement Distributed Session Management?
	
	
	