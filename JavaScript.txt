  
  
   http://javascript.info/tutorial/inheritance 
   
   
 
  1. In JavaScript, what is the difference between var x = 1 and x = 1? 
     Answer in as much or as little detail as you feel comfortable.
	 
     Novice JS programmers might have a basic answer about locals vs globals. 
	 Intermediate JS guys should definitely have that answer, 
	 and should probably mention function-level scope. 
	 Anyone calling themselves an "advanced" JS programmer should be prepared 
	 to talk about locals, implied globals, the window object, function-scope, declaration hoisting, and scope chains. 
	 Furthermore, I'd love to hear about [[DontDelete]], hoisting precedence (parameters vs var vs function), and undefined.
	
  2. Another good question is to ask them to write a sum() function 
     that accepts any number of arguments, and returns their sum. 
	 Then, ask them to use that function (without modification) to sum all the values in an array. 
	 They should write a function that looks like this:
	 
	 function sum() 
	 {
       var i, l, result = 0;  
	   
       for (i = 0, l = arguments.length; i < l; i++) 
	   {
           result += arguments[i];
       }
	   
       return result;
     }
	 
     sum(1,2,3); // 6
	 
	 
	 
	 var data = [1,2,3];
     sum.apply(null, data); // 6
	 
	 
   3. What are global variables? 
      How are they declared? 
	  What are the problems with using globals?
     
      Global variables are available throughout your code: 
	  that is, the variables have no scope. 
	  Local variables scope, on the other hand, is restricted 
	  to where it is declared (like within a function). 
	 
	  The var keyword is used to declare a local variable or object, 
	  while omitting the var keyword creates a global variable.
	  Most JavaScript developers avoid globals. 
	  One reason why is they're averse to naming conflicts between local and globals, 
	  Also, code that depends on globals can be difficult to maintain and test.    
	  
	  // Declare a local variable
      var localVariable = "TechRepublic"
	  
      // Declare a global
      globalVariable = "CNet"
	  
	  
   4. How do you organize your JavaScript code?    
   
	  The key concept here is to get an idea of how the candidate maintains and designs code. 
	  Do they design code that is specific to an application with no possible reuse? 
	  Do they use class inheritance or the module pattern to build reusable code? 
	  These approaches allow multiple developers to work on a project without stepping on their coworkers' toes. 
	  In addition, testing modular code or classes is easier to approach 
	  than a jumbled mess of code thrown together 
	  (look around the Web, and you'll find plenty of examples).
	  
	  function Base() {
	     this.color = "blue"; 
	  }
	  
	  function Sub() {
	     
	  }
	  
	  Sub.prototype = new Base();
	  Sub.prototype.showColor = function() {
	     console.log(this.color);
	  }
	    
	  var instance = new Sub();
	  instance.showColor(); // blue


    4.1 Inheritance using __proto__

          
        var animal = { eats: true }
        var rabbit = { jumps: true }

        rabbit.__proto__ = animal     // inherit
        alert(rabbit.eats)            // true



    4.2 When one property is found in the class and the same property is found in the prototype.
        For example, when eats is in the child object, parent is ignored: 


        var animal      = { eats: true }
        var fedUpRabbit = { eats: false }

        fedUpRabbit.__proto__ = animal 
        alert(fedUpRabbit.eats)       // false
    

    4.3 When a method is put into the base class it becomes available in the child class.

        var animal = 
        {
            eat: function() 
            {
                alert("I'm full");
                this.full = true;
            } 
        }

        var rabbit = 
        {
            jump: function() { /* something */ }
        }

        rabbit.__proto__ = animal 
        rabbit.eat() 

        First, the interpreter looks up rabbit.eat. 
        There’s no eat in rabbit object, so it goes to 
        rabbit.__proto__ and finds it there.                  
        

        The function runs with this = rabbit. 
        So, this.full = true stores the value in the rabbit object:
         

     Reading looks up, writing doesn't
     
     When a property is read, like this.prop, the interpreter looks it in the prototype.
     When a property is assigned, like this.prop = value, 
     then there is no reason to search. 
     The property is written directly into the object (here this).          

   
    4.4 Object.create, Object.getPrototypeOf

     
	  
	  
   
   
	  
   
   
   