


1. Lazy Load:

    Note: The members persisted in the database have to be virtual 
	if you use lazy loading, which is usually best way. 
	If you don't mark them as virtual you get something like this:

   Explain in depth:

    why properties and method must be virtual
    how lazy loading works
	
lazy loading is implemented by substituting a class with a proxy generated at runtime.
Proxy is inherited from the class, so that it can 'intercept' 
method calls and load the actual data lazily.

This interception would only work if methods and properties are virtual, 
because the client code calls them through a reference to the class. 
Client code can be unaware of the fact that it really uses a proxy (derived from the class). 
The actual lazy loading logic is a lot more complex but this is roughly what is going on:


public class Customer {
    public virtual String Name {
        get { return _name; }
    }
}


// code like this gets generated at runtime:
public class CustomerProxy7461293476123947123 : Customer {

    private Customer _target;

    public override String Name {
        get {
            if(_target == null){
                _target = LoadFromDatabase();
            }
            return _target.Name;
        }
    }
}

Customer customer = Session.Load<Customer>(1);  // <-- proxy is returned
// or
Customer customer = salesman.FavoriteCustomer;  // <-- proxy is returned

String name = customer.Name; // <-- proxy's Name



2. What is a SessionFactory? Is it a thread-safe object? 

SessionFactory is Hibernates concept of a single datastore 
and is threadsafe so that many threads can access it concurrently 
and request for sessions and immutable cache of compiled mappings for a single database.


3. What is a Session? Can you share a session object between different theads? 

Session is a light weight and a non-threadsafe object 
(No, you cannot share it between threads) 
that represents a single unit-of-work with the database. 
Sessions are opened by a SessionFactory and then are closed when all work is complete.


public class HibernateUtil 
{ 
    public static final ThreadLocal local = new ThreadLocal(); 

    public static Session currentSession() throws HibernateException 
	{ 
        Session session = (Session) local.get(); 
		
        //open a new session if this thread has no session 
        if (session == null) 
		{ 
            session = sessionFactory.openSession(); 
            local.set(session); 
        } 
		
        return session; 
    } 
} 


4. What are the benefits of detached objects? 


Answer: 

Detached objects can be passed across layers all 
the way up to the presentation layer without 
having to use any DTOs (Data Transfer Objects). 
You can later on re-attach the detached objects to another session. 


Q. What are the pros and cons of detached objects? 

Answer: 

Pros: 

When long transactions are required due to user think-time, 
it is the best practice to break the long transaction 
up into two or more transactions. 
You can use detached objects from the first transaction 
to carry data all the way up to the presentation layer. 
These detached objects get modified outside a transaction 
and later on re-attached to a new transaction via another session. 


Cons 

In general, working with detached objects is quite cumbersome, 
and better to not clutter up the session with them if possible. 
It is better to discard them and re-fetch them on subsequent requests. 
This approach is not only more portable but also more efficient because 
- the objects hang around in Hibernate's cache anyway. 

Also from pure rich domain driven design perspective 
it is recommended to use DTOs (DataTransferObjects) 
and DOs (DomainObjects) to maintain the separation 
between Service and UI tiers.	



5. How does Hibernate distinguish between transient 
   (i.e. newly instantiated) and detached objects? 

Answer 

Hibernate uses the version property, if there is one. 
If not uses the identifier value. 
No identifier value means a new object. 
This does work only for Hibernate managed surrogate keys. 
Does not work for natural keys and assigned 
(i.e. not managed by Hibernate) surrogate keys. 
Write your own strategy with Interceptor.isUnsaved(). 


6. What is the difference between the session.get() method and the session.load() method? 

Both the session.get(..) and session.load() methods 
create a persistent object by loading the required object from the database. 
But if there was not such object in the database 
then the method session.load(..) throws an exception 
whereas session.get(&) returns null. 

get loads full object while load can return a proxy with a possibility
of a further lazy loading.


7. What is the difference between the session.update() method and the session.lock() method? 

Both of these methods and saveOrUpdate() method 
are intended for reattaching a detached object. 

The session.lock() method simply reattaches the object 
to the session without checking 
or updating the database on the assumption 
that the database in sync with the detached object. 

It is the best practice to use either session.update(..) or session.saveOrUpdate(). 
Use session.lock() only if you are absolutely sure 
that the detached object is in sync with your detached object 
or if it does not matter because you will be overwriting 
all the columns that would have changed later on within the same transaction. 

Note: 
When you reattach detached objects you need to make sure 
that the dependent objects are reatched as well. 


8. How would you reatach detached objects to a session 
when the same object has already been loaded into the session? 

You can use the session.merge() method call. 


9. Difference between save, persist and saveOrUpdate methods in Hibernate?

After get vs load, this is another Hibernate Interview question 
which appears quite often. 
All three methods i.e. save(), saveOrUpdate() and persist() 
is used to save objects into database, 
but has subtle differences 
e.g. save() can only INSERT records but saveOrUpdate() 
can either INSERT or UPDATE records. 
Also, return type of save() is a Serializable object, 
while return type of persist() method is void. 
You can also check save vs persist vs saveOrUpdate for complete differences between them in hibernate.


10. What is difference between sorted and ordered collection in hibernate?

This is one of the easy Hibernate interview question you ever face. 
A sorted collection is sorted in memory by using Java Comparator, 
while a ordered collection uses database's order by clause for ordering. 
For large data set it's better to use ordered collection 
to avoid any OutOfMemoryError in Java, by trying to sort them in memory.


11. What does Session lock() method do in Hibernate?

This one is one of the tricky Hibernate Interview question, 
because Session's lock() method reattach object 
without synchronizing or updating with database. 
So you need to be very careful while using lock() method. 
By the way you can always use Session's update() method 
to sync with database during reattachment. 
Some time this Hibernate question is also asked as 
what is difference between Session's lock() and update() method. 
You can use this key point to answer that question as well.


12. What is Second level Cache in Hibernate?

This is one of the first interview question 
related to caching in Hibernate, you can expect few more. 
Second level Cache is maintained at SessionFactory level 
and can improve performance by saving few database round trip. 
Another worth noting point is that second level cache 
is available to whole application rather than any particular session.

13. Why it's important to provide no argument constructor in Hibernate Entities?

Every Hibernate Entity class must contain a no argument constructor, 
because Hibernate framework creates instance of them using Reflection API, 
by calling Class.newInstance() method. 
This method will throw InstantiationException if 
it doesn't found no argument constructor inside Entity class.


14. Handling versioning and concurrency


In the Entity base class, add a Version property, as shown in the following code:

public abstract class Entity<TId>
{
   public virtual TId Id { get; protected set; }
   protected virtual int Version { get; set; }
   public override bool Equals(object obj)
   {
       return Equals(obj as Entity<TId>);
   }
}



In the Product mapping, add the version element as shown in the following code:
<natural-id mutable="true">
<property name="Name" not-null="true" />
</natural-id>
<version name="Version" />
<property name="Description" />
<property name="UnitPrice" not-null="true" />



In the ActorRole mapping, add the version element shown here:
<id name="Id">
<generator class="guid.comb" />
</id>
<version name="Version" />
<property name="Actor" not-null="true" />
<property name="Role" not-null="true" />




15. Pessimistic cincurrency.

To implement this type of
locking with NHibernate, your application must call session.Lock within a transaction.


LockMode.Upgrade may be acquired upon explicit user request using SELECT ... FOR UPDATE on databases which support that syntax.
LockMode.UpgradeNoWait may be acquired upon explicit user request using a SELECT ... FOR UPDATE NOWAIT under Oracle.
LockMode.Read is acquired automatically when NHibernate reads data under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user request.


A call to ISession.Load(), specifying a LockMode.
A call to ISession.Lock().
A call to IQuery.SetLockMode().



If ISession.Load() is called with Upgrade or UpgradeNoWait, 
and the requested object was not yet loaded by the session, 
the object is loaded using SELECT ... FOR UPDATE. 

If Load() is called for an object that is already loaded 
with a less restrictive lock than the one requested, 
NHibernate calls Lock() for that object

ISession.Lock() performs a version number check if the specified lock mode is Read, Upgrade or UpgradeNoWait. 


16. Object states


 Transient objects

When using NHibernate, simply creating objects using the new operator will not make
them immediately persistent. At this point, their state is transient, which means they
aren’t associated with any database table row. This is similar to any other object in a
.NET application. As you would expect, their state is lost as soon as they’re dereferenced
(no longer referenced by any other object) and they become inaccessible and available
for garbage collection.

Objects that are referenced only by other transient instances are, by default, also
transient. To transition an object from transient to persistent state, there are two
choices. You can Save() it using the persistence manager, or create a reference to it from
an already-persistent instance and take advantage of transitive persistence

Persistent objects


A persistent instance is any instance with a database identity, as defined in section 3.5.
That means a persistent object has a primary key value set as its database identifier.


Detached objects


When a transaction completes and the data is written to the database, the persistent
instances associated with the persistence manager still exist in memory.

But in the case of NHibernate, these instances lose their association with the persistence
manager when you Close() the ISession

Because they’re no longer associated
with a persistence manager, we refer to these objects as detached

Fortunately, NHibernate lets you use these instances in a new transaction by reassociating
them with a new persistence manager.


The ability to return objects from one transaction to the presentation
Working with persistent objects
layer and later reuse them in a new transaction is one of NHibernate’s main selling
points.



17. When NHibernate does sync loaded objects with database.

Persistent instances participate in transactions—their state is synchronized with
the database at the end of the transaction.

When a transaction commits, state held in
memory is propagated to the database by the execution of SQL INSERT, UPDATE, and
DELETE statements.

For example, NHibernate
may synchronize with the database before execution of a query. This ensures
that queries are aware of changes made earlier during the transaction.


When in our transaction we have inserted a lot of items and 
perform a query which may include these items.

NHibernate will do syncrinize and inserts those items into database 
before executing a query.


18. Making an object persistent

User user = new User();
user.Name.Firstname = "Mark";
user.Name.Lastname = "Monster";

using(ISession session = sessionFactory.OpenSession())
using(session.BeginTransaction())
{
   session.Save(user);
   session.Transaction.Commit();
}

// now user is a detached object
// We update its state from UI and
// want to sync state with the database
// 

user.Password = "secret";
using( ISession sessionTwo = sessionFactory.OpenSession() )
using( sessionTwo.BeginTransaction() ) 
{
   sessionTwo.Update(user);
   user.Username = "jonny";
   sessionTwo.Transaction.Commit();
}


Let’s first look at the Update() method. Using Update() forces an update to the
persistent state of the object in the database;

The important thing is that the call to Update() 
is used to reassociate the detached instance
with the new ISession and the current transaction.

NHibernate will treat the object as
dirty and therefore schedule the SQL UPDATE regardless of whether the object has been
updated. This makes Update() a safe way to reassociate objects with a Session, because
you know changes will be propagated to the database.



Now, let’s look a the Lock() method. 
A call to Lock() associates the object with the
ISession without forcing NHibernate to treat the object as dirty. 
Consider this example:


using( ISession sessionTwo = sessionFactory.OpenSession() )
{
   using( sessionTwo.BeginTransaction() ) 
   {
       sessionTwo.Lock(user, LockMode.None);
       user.Password = "secret";
       user.LoginName = "jonny";
       sessionTwo.Transaction.Commit();
   }
}


The previous code specifies LockMode.None, which tells NHibernate not to perform
a version check or obtain any database-level locks when reassociating the object
with the ISession. If we specified LockMode.Read or LockMode.Upgrade, NHibernate
would execute a SELECT statement in order to perform a version check 
(and to set an upgrade lock).



19. When use session.Get() and when use session.Load()?

Choosing between Get() and Load() is easy: if you’re certain the persistent object
exists, and nonexistence would be considered exceptional, Load() is a good option. If
you aren’t certain there is a persistent instance with the given identifier, use Get() and
test the return value to see if it’s null.


20. What are different fetch strategies in NHibernate?


IMMEDIATE FETCHING

Immediate association fetching occurs when you retrieve an entity from the database
and then immediately retrieve another associated entity or entities in a further
request to the database or cache. Immediate fetching isn’t usually an efficient fetching
strategy unless you expect the associated entities to almost always be cached already.


LAZY FETCHING

Lazy fetching lets you decide how much of the object graph is loaded in the first
database hit and which associations should be loaded only when they’re first accessed.
Lazy fetching is a foundational concept in object persistence and the first step to
attaining acceptable performance.


EAGER (OUTER JOIN) FETCHING

Eager fetching lets you explicitly specify which associated objects should be loaded
together with the referencing object. NHibernate can then return the associated
objects in a single database request, utilizing a SQL outer join.


BATCH FETCHING

Batch fetching isn’t strictly an association fetching strategy; it’s a technique that may
help improve the performance of lazy (or immediate) fetching. Usually, when you
load an object or collection, your SQL WHERE clause specifies the identifier of the
object or the object that owns the collection


21. What are session Flush modes?

Flushing the ISession state to the database at the end of a database transaction is
required in order to make the changes durable and is the common case. 
NHibernate doesn’t flush before every query. 
But if changes are held in memory that would affect
the results of the query, NHibernate will, by default, synchronize first.

FlushMode.Auto—The default. Enables the behavior just described.

FlushMode.Commit—Specifies that the session won’t be flushed before query
execution (it will be flushed only at the end of the database transaction). Be
aware that this setting may expose you to stale data: modifications you made to
objects only in memory may conflict with the results of the query.

FlushMode.Never—Lets you specify that only explicit calls to Flush() result in
synchronization of session state with the database.



22. What are connection-release modes?


OnClose—This was the only mode available in NHibernate 1.0. In this case, the
session releases the connection when it’s closed.

AfterTransaction—This is the default mode in NHibernate 1.2. The connection
is released as soon as the transaction completes.

Note that you can use the Disconnect() method of the ISession interface to force
the release of the connection (without closing the session) and the Reconnect()
method to tell the session to obtain a new connection when needed.



23. Pessimistic lock example.


ITransaction tx = session.BeginTransaction();
Category cat = session.Get<Category>(catId);
cat.Name = "New Name";
tx.Commit();


It’s possible to make this transaction use a pessimistic lock as follows:
ITransaction tx = session.BeginTransaction();
Category cat = session.Get<Category>(catId, LockMode.Upgrade);
cat.Name = "New Name";
tx.Commit();

With LockMode.Upgrade, NHibernate loads the Category using a SELECT...FOR
UPDATE, thus locking the retrieved rows in the database until they’re released when
the transaction ends
               

24. What is LockMode.Read?
			   
			  
Item item = ItemDAO.Load(1);
Bid bid = new Bid();
item.AddBid(bid);
//...
ITransaction tx = session.BeginTransaction();
session.Lock(item, LockMode.Read);
tx.Commit();



This code performs a version check on the detached Item instance to verify that the
database row wasn’t updated by another transaction since it was retrieved. If it was
updated, a StaleObjectStateException is thrown.


25. What are possible solutions in optimistic lock?

Last commit wins —

Both updates are saved to the database, but the last one overwrites
the first. No error message is shown to anyone, and the first update is
silently lost forever.

First commit wins —

The first update is saved. When the second user attempts to
save her changes, she receives an error message saying “your updates were lost
because someone else updated the record while you were editing it.” The user
must start her edits again and hope she has more luck next time she clicks Save!
This option is often called optimistic locking—the application optimistically
assumes there won’t be problems, but it checks and reports if there are				

Merge conflicting updates —

The first modification is persisted. When the second
user saves, he’s given the option of merging the records. This is also falls under
the category of optimistic locking.


26. What are caching strategies?

Transaction scope —

Attached to the current unit of work, which may be an actual
database transaction or a conversation. It’s valid and used as long as the unit of
work runs. Every unit of work has its own cache.


Process scope —

Shared among many (possibly concurrent) units of work or transactions.
Data in the process-scope cache is accessed by concurrently running
transactions, obviously with implications on transaction isolation. A processscope
cache may store the persistent instances themselves in the cache, or it
may store just their persistent state in some disassembled format.


Cluster scope —

Shared among multiple processes on the same machine or
among multiple machines in a cluster. It requires some kind of remote process
communication to maintain consistency.



27. What is the first level cache?

USING THE FIRST-LEVEL CACHE
The session cache ensures that when the application requests the same persistent
object twice in a particular session, it gets back the same (identical).

Changes made in a particular unit of work are always immediately visible to all
other code executed inside that unit of work.


28. What is the second level cache?

The NHibernate second-level cache has process or cluster scope; 
all sessions share the same second-level cache. 
The second-level cache has the scope of an ISessionFactory.
Persistent instances are stored in the second-level cache in a disassembled form.
Think of disassembly as a process a bit like serialization 
(but the algorithm is much, much faster than .NET serialization).


29. What are cache concurrency strategies?

Read-write —

Maintains read-committed isolation, using a timestamping mechanism.
It’s available only in nonclustered environments. Use this strategy for
read-mostly data where it’s critical to prevent stale data in concurrent transactions,
in the rare case of an update.


Nonstrict-read-write —

Makes no guarantee of consistency between the cache and
the database. If there is a possibility of concurrent access to the same entity, you
should configure a sufficiently short expiry timeout. Otherwise, you may read
stale data in the cache. Use this strategy if data rarely changes (many hours,
days, or even a week) and a small likelihood of stale data isn’t of critical concern.
NHibernate invalidates the cached element if a modified object is flushed,
but this is an asynchronous operation, without any cache locking or guarantee
that the retrieved data is the latest version.

Read-only —

Suitable for data that never changes. Use it for reference data only.


